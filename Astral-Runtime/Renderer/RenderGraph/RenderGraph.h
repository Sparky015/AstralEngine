/**
* @file RenderGraph.h
* @author Andrew Fagan
* @date 7/7/2025
*/

#pragma once

#include "Core/Containers/DirectedGraph.h"
#include "Renderer/RHI/Resources/Texture.h"
#include "Renderer/RHI/Resources/DescriptorSet.h"
#include "RenderGraphPass.h"

#include <vector>

namespace Astral {

    using PassIndex = uint8;
    static constexpr PassIndex NullRenderPassIndex = -1;


    /**
     * @brief Contains information needed by render passes when they are being executed
     */
    struct RenderGraphPassExecutionContext
    {
        CommandBufferHandle CommandBuffer;
        RenderPassHandle RenderPass;
        DescriptorSetHandle ReadAttachments;
    };


    /**
     * @brief Manages the creation and execution of a render graph consisting of multiple render passes.
     *        Provides methods to build, execute, and resize render graph resources.
     */
    class RenderGraph
    {
    public:

        // TODO: Add support for writing to a texture created by another render pass
        // TODO: Add support for adding buffers as a resource to a render pass
        // TODO: Add support for texture aliasing

        /**
         * @brief Marks the beginning of calls to collect render passes and other information to build the render graph
         * @param maxFramesInFlight The max frames in flight
         * @param debugName A name to assign to the graph that is used to label graph operators with
         * @post  @ref EndBuildingRenderGraph is called after all passes and output images are added to create the render graph
         * @warning This invalidates any previous render graph built in this instance
         */
        void BeginBuildingRenderGraph(uint32 maxFramesInFlight, const std::string_view& debugName = "Untitled Render Graph");

        /**
         * @brief Adds a render pass to the render graph
         * @param pass The render pass to add to the graph
         * @pre   @ref BeginBuildingRenderGraph is called first
         * @post  @ref EndBuildingRenderGraph is called after all passes and output resources are added
         */
        void AddPass(const RenderGraphPass& pass);

        /**
         * @brief Sets the output of the render graph to a specific attachment in a render pass
         * @param pass The render pass that the output attachment is in
         * @param attachmentName The name of the attachment that should use the output textures
         * @param offscreenTargets The textures that will be used as output textures
         */
        void SetOutputAttachment(const RenderGraphPass& pass, std::string_view attachmentName, const std::vector<TextureHandle>& offscreenTargets);

        /**
         * @brief Sets the output of the render graph to a specific attachment in a render pass
         * @param pass The render pass that the output attachment is in
         * @param attachmentName The name of the attachment that should use the output textures
         * @param swapchainTargets The render targets that will be used as output textures
         */
        void SetOutputAttachment(const RenderGraphPass& pass, std::string_view attachmentName, const std::vector<RenderTargetHandle>& swapchainTargets);

        /**
         * @brief Ends the building of the render graph and compiles the render graph
         * @pre   @ref BeginBuildingRenderGraph is called first
         */
        void EndBuildingRenderGraph();

        /**
         * @brief Starts running the render passes in the graph
         * @param commandBuffer The command buffer to record render commands generated by the render graph passes into
         * @param swapchainImageIndex The swapchain image index acquired this frame
         * @note  Barriers and layout transitions happen automatically between render passes if needed
         * @pre   @ref EndBuildingRenderGraph is called first to create render graph and its resources
         */
        void Execute(CommandBufferHandle commandBuffer, uint32 swapchainImageIndex);

        /**
         * @brief   Gets the execution context for a render pass
         * @return  The execution context for a render pass
         * @warning This method should not be called outside a render pass callback
         */
        const RenderGraphPassExecutionContext& GetExecutionContext() const { return m_ExecutionContext; }

        /**
         * @brief Recreates the render graph resources (textures, framebuffers, and descriptor sets)
         * @param offscreenTargets The new and correctly sized output targets to use
         * @note  This method uses the size of the swapchain targets to assume the size of the surface being rendered to
         * @pre   @ref EndBuildingRenderGraph is called first to create render graph and its resources
         */
        void ResizeResources(const std::vector<TextureHandle>& offscreenTargets);

        /**
         * @brief Recreates the render graph resources (textures, framebuffers, and descriptor sets)
         * @param swapchainTargets The new and correctly sized output targets to use
         * @note  This method uses the size of the swapchain targets to assume the size of the surface being rendered to
         * @pre   @ref EndBuildingRenderGraph is called first to create render graph and its resources
         */
        void ResizeResources(const std::vector<RenderTargetHandle>& swapchainTargets);

    private:

        /**
         * @brief Contains the resources for a render pass to be executed
         */
        struct RenderPassResources
        {
            DescriptorSetHandle ReadAttachmentDescriptorSet;
            FramebufferHandle Framebuffer;
            std::vector<TextureHandle> AttachmentTextures;
        };

        /**
         * @brief Builds the directed acyclic render graph
         * @details The edges in the graph represent a dependency between render passes
         */
        void BuildRenderGraph();

        /**
         * @brief Figures out the execution order of all the render passes
         * @details Does a topological sort to figure out the render passes that don't have a dependency to run first
         */
        void SolveRenderPassExecutionOrder();

        /**
         * @brief Creates the RHI render pass object for each render pass
         */
        void BuildRenderPassObjects();

        /**
         * @brief Creates the RHI render pass object for each render pass
         */
        void BuildRenderPassResources();

        /**
         * @brief Gets the render pass index from a @ref RenderGraphPass instance
         */
        PassIndex GetRenderPassIndex(const RenderGraphPass& pass);

        /**
         * @brief Adds the current render graph resources to the render graph resources hold
         */
        void AddRenderGraphResourcesToHold();

        /**
         * @brief Updates the render graph resources hold by removing resources from the hold when necessary
         */
        void UpdateRenderGraphResourcesHold();


        /**
         * @brief Contains all the resources for each render pass in the render graph
         */
        using RenderGraphResources = std::vector<std::vector<RenderPassResources>>;


        // Contains all the render graph passes that were added to the graph
        std::vector<RenderGraphPass> m_Passes;


        // The graph used to figure out dependencies between render graph and to cull non-contributing render passes
        AEDirectedGraph<PassIndex> m_RenderGraph;
        std::vector<AEDirectedGraph<PassIndex>::Vertex> m_RenderPassNodes;


        // Contains the order of render passes to execute in such that dependencies are ran first
        std::vector<PassIndex> m_ExecutionOrder;
        RenderGraphPassExecutionContext m_ExecutionContext{};


        // Contains the RHI objects needed to execute all render passes that are in the execution order
        std::vector<RenderPassHandle> m_RenderPasses;
        RenderGraphResources m_RenderPassResources;
        uint32 m_MaxFramesInFlight{0};


        // Vectors to hold render graph resources after a resize, so they don't get deleted while being used on the gpu
        std::vector<RenderGraphResources> m_RenderPassResourcesHold;
        std::vector<std::vector<RenderPassHandle>> m_RenderPassesHold;
        std::vector<uint32> m_FramesTillClear;


        // The render pass and attachment where the output textures should be used instead of creating new textures
        PassIndex m_OutputRenderPassIndex{0};
        std::string_view m_OutputAttachmentName;


        // Output textures and their dimensions
        std::vector<TextureHandle> m_OffscreenOutputTargets;
        UVec2 m_ViewportDimensions{0};


        // Debug name for the render graph
        std::string_view m_DebugName;
    };

}


// TODO: Refactor impl for clarity
// TODO: Add fallback if render graph compilation fails during a release build